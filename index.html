<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>给宝宝的小爱心</title>
<style>
  :root{
    --bg1:#fff0f6;
    --bg2:#ffeafa;
    --accent1:#ff6fa3;
    --accent2:#ff2e6d;
    --accent3:#ff9bb3;
    --glow: rgba(255,82,130,0.25);
  }

  html,body{
    height:100%;
    margin:0;
    font-family: -apple-system, "PingFang SC", "Microsoft YaHei", "Segoe UI", Roboto, sans-serif;
    -webkit-font-smoothing:antialiased;
  }

  /* 背景：动感渐变 + 轻微浮动 */
  .stage{
    min-height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    flex-direction:column;
    background: radial-gradient(circle at 20% 20%, rgba(255,230,240,0.6), transparent 15%),
                radial-gradient(circle at 80% 80%, rgba(255,245,220,0.6), transparent 12%),
                linear-gradient(135deg, var(--bg1), var(--bg2));
    overflow:hidden;
    position:relative;
    animation: bgShift 8s ease-in-out infinite;
  }
  @keyframes bgShift{
    0%{filter: hue-rotate(0deg) saturate(1);}
    50%{filter: hue-rotate(8deg) saturate(1.05);}
    100%{filter: hue-rotate(0deg) saturate(1);}
  }

  /* 主心形：使用伪元素构造，添加渐变、发光、投影和跳动 */
  .heart-wrap{
    position:relative;
    width:240px;
    height:220px;
    display:flex;
    align-items:center;
    justify-content:center;
    transform-origin:center;
  }

  .heart{
    width:140px;
    height:120px;
    position:relative;
    transform: rotate(45deg);
    border-radius:20px 20px 0 0;
    background: linear-gradient(180deg, #ff90b0 0%, #ff3a73 60%, #ff2e6d 100%);
    box-shadow: 0 12px 36px rgba(255,60,120,0.12), 0 0 80px rgba(255,82,130,0.14);
    animation: heartBeat 1.6s ease-in-out infinite, gentleSway 6s ease-in-out infinite;
    filter: drop-shadow(0 10px 30px rgba(255,100,140,0.12));
  }

  /* 保留两个圆瓣（lobe），做更柔和的过渡 */
  .heart::before,
  .heart::after{
    content:"";
    position:absolute;
    width:140px;
    height:120px;
    background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.00)),
                linear-gradient(180deg, #ff90b0 0%, #ff3a73 60%);
    border-radius:50%;
    left:0;
    top:-60px;
    transform-origin:center;
    opacity:0.98;
    filter: blur(0.6px);
  }
  .heart::after{
    left:-60px;
    top:0;
  }

  /* 缓慢放大的发光层（稍微放慢节奏）*/
  .heart-glow{
    position:absolute;
    width:240px;
    height:240px;
    border-radius:50%;
    background:
      radial-gradient(circle at 30% 30%, rgba(255,110,160,0.18), transparent 22%),
      radial-gradient(circle at 70% 70%, rgba(255,150,190,0.10), transparent 18%);
    filter: blur(18px);
    z-index:-2;
    animation: glowPulse 3.2s ease-in-out infinite;
  }

  /* 光泽移动更慢更悠扬 */
  .heart-sheen{
    position:absolute;
    width:96px;height:84px;
    left:50%;top:50%;
    transform:translate(-50%,-50%) rotate(45deg);
    background: linear-gradient(120deg, rgba(255,255,255,0.45), rgba(255,255,255,0.06));
    border-radius:14px 14px 0 0;
    filter: blur(6px);
    mix-blend-mode:screen;
    animation: sheenMove 4.2s infinite linear;
    pointer-events:none;
  }

  /* 新增：心形叠层，增加柔和光斑与微旋转，增加浪漫感 */
  .heart-overlay{
    position:absolute;
    width:260px;
    height:260px;
    left:50%; top:50%;
    transform:translate(-50%,-50%);
    border-radius:50%;
    background:
      radial-gradient(circle at 30% 30%, rgba(255,220,238,0.28), transparent 18%),
      radial-gradient(circle at 70% 70%, rgba(255,240,245,0.22), transparent 20%);
    mix-blend-mode: soft-light;
    pointer-events:none;
    z-index:-1;
    filter: blur(8px);
    animation: overlayPulse 5.6s ease-in-out infinite;
  }

  /* 动画 keyframes（替换/新增） */
  @keyframes heartBeat{
    0%,100%{ transform: rotate(45deg) scale(1) translateY(0); }
    50%{ transform: rotate(45deg) scale(1.12) translateY(-6px); }
  }
  @keyframes gentleSway{
    0%{ transform: rotate(44.6deg) translateY(0); }
    25%{ transform: rotate(45.4deg) translateY(-2px); }
    50%{ transform: rotate(45deg) translateY(0); }
    75%{ transform: rotate(45.6deg) translateY(-2px); }
    100%{ transform: rotate(44.6deg) translateY(0); }
  }
  @keyframes glowPulse{
    0%,100%{ transform: scale(1); opacity:0.9; }
    50%{ transform: scale(1.14); opacity:1; }
  }
  @keyframes sheenMove{
    0%{ transform:translate(-62%,-56%) rotate(45deg); opacity:0.78; }
    50%{ transform:translate(-38%,-44%) rotate(45deg); opacity:1; }
    100%{ transform:translate(-62%,-56%) rotate(45deg); opacity:0.78; }
  }
  @keyframes overlayPulse{
    0%{ transform: translate(-50%,-50%) scale(0.98) rotate(-2deg); opacity:0.9; }
    50%{ transform: translate(-50%,-52%) scale(1.03) rotate(2deg); opacity:1; }
    100%{ transform: translate(-50%,-50%) scale(0.98) rotate(-2deg); opacity:0.9; }
  }

  /* 中心小心形闪烁（填色渐变移动） */
  .heart-sheen{
    position:absolute;
    width:80px;height:70px;
    left:50%;top:50%;
    transform:translate(-50%,-50%) rotate(45deg);
    background: linear-gradient(120deg, rgba(255,255,255,0.4), rgba(255,255,255,0.06));
    border-radius:12px 12px 0 0;
    filter: blur(6px);
    mix-blend-mode:screen;
    animation: sheenMove 2.6s infinite linear;
    pointer-events:none;
  }
  @keyframes sheenMove{
    0%{ transform:translate(-62%,-56%) rotate(45deg); opacity:0.78; }
    50%{ transform:translate(-38%,-44%) rotate(45deg); opacity:1; }
    100%{ transform:translate(-62%,-56%) rotate(45deg); opacity:0.78; }
  }

  /* 漂浮小爱心：由 JS 生成并上升消失 */
  .float-heart{
    position:absolute;
    width:18px;height:18px;
    transform: rotate(45deg);
    background: linear-gradient(180deg, var(--accent3), var(--accent2));
    border-radius:4px 4px 0 0;
    opacity:0.95;
    pointer-events:none;
    box-shadow:0 6px 12px rgba(255,80,140,0.18);
  }
  .float-heart::before, .float-heart::after{
    content:"";
    position:absolute;
    width:18px;height:18px;
    background:inherit;
    border-radius:50%;
    top:-9px; left:0;
  }
  .float-heart::after{ left:-9px; top:0; }

/* 替换原来的 .text 规则为下面内容 */
.text{
    position:relative;             /* 便于放置伪元素作为底板 */
    margin-top:26px;
    font-size:20px;
    font-weight:700;
    white-space:nowrap;
    overflow:hidden;
    box-sizing:content-box;

    /* 文字渐变，保留原有样式 */
    background: linear-gradient(90deg, #fff7ff, #ffd6e6 40%, #fff 80%);
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;

    /* 保持打字效果（宽度按字符数调节）*/
    width:10.5ch;
    border-right: 2px solid rgba(255,255,255,0.7);
    animation: typing 2.4s steps(11,end) 1, blink 1s step-end infinite;

    z-index:1;                     /* 保证文字在伪元素上层 */
    padding:8px 18px;              /* 为底板留出空间 */
    border-radius:12px;
    text-shadow: 0 6px 18px rgba(0,0,0,0.22); /* 加强可读性 */
}

/* 底板：半透明 + 毛玻璃模糊，增强与背景的对比 */
.text::before{
    content:'';
    position:absolute;
    left:0;
    top:50%;
    transform:translateY(-50%);
    width:100%;
    height:100%;
    background: rgba(237, 46, 122, 0.18); /* 深色半透明，可调节透明度 */
    border-radius:12px;
    z-index:-1;
    backdrop-filter: blur(6px); /* 毛玻璃效果（移动端现代浏览器支持）*/
    -webkit-backdrop-filter: blur(6px);
    box-shadow: 0 8px 20px #f65a9814;
}s

/* 小屏适配（必要时减小内边距与宽度） */
@media (max-width:420px){
    .text{ font-size:18px; width:9ch; padding:6px 12px; border-radius:10px; }
    .text::before{ border-radius:10px; }
}
</style>
</head>
<body>
  <div class="stage">
    <!-- 替换原来 <div class="heart"> ... </div> 为 Canvas 实现 -->
    <div class="heart-wrap" aria-hidden="true">
      <canvas id="heartCanvas" width="720" height="620" style="width:100%;height:100%;display:block;"></canvas>
      <div class="heart-glow"></div>
      <div class="heart-sheen"></div>
      <div class="heart-overlay" aria-hidden="true"></div>
    </div>

    <div class="text">宝宝，我想你了 ❤</div>

    <div class="footer-note">我每时每刻都在想我的宝宝哦 ~</div>
  </div>

  <script>
/* Canvas 粒子心（闪烁 + 拖尾）实现
   - 把大量粒子拉到心形轨迹并微抖动闪烁（glitter）
   - 从心形底部定点发出若干拖尾粒子（流动触须效果）
*/
(function(){
  const canvas = document.getElementById('heartCanvas');
  const ctx = canvas.getContext('2d', { alpha: true });
  let DPR = Math.max(1, window.devicePixelRatio || 1);
  function resize() {
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.round(rect.width * DPR);
    canvas.height = Math.round(rect.height * DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
    center = { x: rect.width/2, y: rect.height/2 - 10 };
    scale = Math.min(rect.width, rect.height) / 38; // 38 from param scale
  }
  window.addEventListener('resize', resize);
  resize();

  // 生成心形目标点（参数方程）
  function heartXY(t){
    // param heart (classic): x=16 sin^3 t, y=13 cos t -5 cos 2t -2 cos3t - cos4t
    const x = 16 * Math.pow(Math.sin(t),3);
    const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
    return { x, y };
  }

  // 粒子定义
  const PARTICLE_COUNT = 900; // 可根据性能调节（手机可降到 600）
  const particles = [];
  let center = { x: canvas.width/ (2*DPR), y: canvas.height/(2*DPR) - 10 };
  let scale = Math.min(canvas.width, canvas.height) / (38 * DPR);

  for(let i=0;i<PARTICLE_COUNT;i++){
    const t = Math.random() * Math.PI * 2;
    // 随机心形目标
    const p = heartXY(t);
    const tx = center.x + p.x * scale + (Math.random()-0.5)*8;
    const ty = center.y - p.y * scale + (Math.random()-0.5)*8;
    particles.push({
      x: center.x + (Math.random()-0.5)*200, // start from around center
      y: center.y + (Math.random()-0.5)*200,
      tx, ty,
      vx: 0, vy: 0,
      size: Math.random()*1.6 + 0.6,
      hue: 330 + Math.random()*20, // pink range
      life: Math.random()*4000 + 2000,
      flick: Math.random()*1200,
      phase: Math.random()*Math.PI*2
    });
  }

  // 拖尾粒子池（从心底发出）
  const trails = [];
  function emitTrail(){
    const baseX = center.x;
    const baseY = center.y + 36 * scale; // 底部位置
    const count = 6 + Math.floor(Math.random()*6);
    for(let i=0;i<count;i++){
      trails.push({
        x: baseX + (Math.random()-0.5)*18,
        y: baseY + (Math.random()*8),
        vx: (Math.random()-0.5)*0.6,
        vy: - (1.5 + Math.random()*2.2),
        life: 1200 + Math.random()*1400,
        size: 1.2 + Math.random()*2.6,
        hue: 320 + Math.random()*40,
        t0: performance.now()
      });
    }
    // cap trail count
    if(trails.length > 500) trails.splice(0, trails.length-500);
  }

  // 渲染循环
  let last = performance.now();
  function tick(now){
    const dt = now - last;
    last = now;
    // slight background clear with alpha to create glow trails
    ctx.clearRect(0,0,canvas.width/DPR, canvas.height/DPR);

    // draw glow radial for big heart
    const g = ctx.createRadialGradient(center.x, center.y, 10, center.x, center.y, Math.max(canvas.width, canvas.height));
    g.addColorStop(0, 'rgba(255,110,160,0.22)');
    g.addColorStop(0.4, 'rgba(255,140,180,0.08)');
    g.addColorStop(1, 'rgba(255,140,160,0)');
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(center.x, center.y, 140* (scale/ (canvas.width/360)), 0, Math.PI*2);
    ctx.fill();

    // update particles toward targets (spring motion)
    for(let i=0;i<particles.length;i++){
      const p = particles[i];
      // tiny wander on target positions for glitter flicker
      const wobble = Math.sin((now + p.phase*800)/ (1200 + p.flick)) * 6;
      const tx = p.tx + wobble * Math.cos(p.phase);
      const ty = p.ty + wobble * Math.sin(p.phase);

      // spring physics
      const ax = (tx - p.x) * 0.0025 * Math.min(3, dt/16);
      const ay = (ty - p.y) * 0.0025 * Math.min(3, dt/16);
      p.vx += ax;
      p.vy += ay;
      // damping
      p.vx *= 0.92;
      p.vy *= 0.92;
      p.x += p.vx * (dt/16);
      p.y += p.vy * (dt/16);

      // flicker alpha
      const alpha = 0.6 + 0.4 * Math.abs(Math.sin((now + i*13) / (600 + (i%7)*30)));

      // draw glow particle
      const rad = p.size * (1 + 0.5*Math.sin(now/800 + i));
      ctx.beginPath();
      const col = `hsla(${p.hue},90%,65%,${alpha*0.9})`;
      // outer soft
      ctx.fillStyle = col;
      ctx.globalCompositeOperation = 'lighter';
      ctx.fillRect(p.x- rad*1.6, p.y- rad*1.6, rad*3.2, rad*3.2);
      // small core
      ctx.beginPath();
      ctx.fillStyle = `hsla(${p.hue},95%,72%,${Math.min(1,alpha+0.15)})`;
      ctx.arc(p.x, p.y, rad*0.6, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalCompositeOperation = 'source-over';

    // trails update & draw (give jellyfish like flowing tails)
    for(let i=trails.length-1;i>=0;i--){
      const tr = trails[i];
      const age = now - tr.t0;
      if(age > tr.life){ trails.splice(i,1); continue; }
      // gravity & tiny wobble
      tr.vx += (Math.sin((now + i*29)/1800))*0.001;
      tr.vy += 0.004; // slight gravity downward (but vy is negative at start moves upward)
      tr.x += tr.vx * (dt/16);
      tr.y += tr.vy * (dt/16);
      const tnorm = age / tr.life;
      const a = 1 - tnorm;
      // draw trailing glow line segment
      ctx.beginPath();
      ctx.globalCompositeOperation = 'lighter';
      const gradient = ctx.createRadialGradient(tr.x, tr.y, 0, tr.x, tr.y, tr.size*8);
      const color = `hsla(${tr.hue},95%,68%,${0.9*a})`;
      gradient.addColorStop(0, color);
      gradient.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(tr.x - tr.size*4, tr.y - tr.size*4, tr.size*8, tr.size*8);

      // tiny core
      ctx.beginPath();
      ctx.fillStyle = `hsla(${tr.hue},90%,70%,${0.95*a})`;
      ctx.arc(tr.x, tr.y, tr.size*0.9, 0, Math.PI*2);
      ctx.fill();
      ctx.globalCompositeOperation = 'source-over';
    }

    // periodic small emissions from bottom of heart
    if(Math.random() < 0.06) emitTrail();

    requestAnimationFrame(tick);
  }

  // reposition particles' targets on resize or occasionally to maintain shape
  function recomputeTargets(){
    for(let i=0;i<particles.length;i++){
      const t = (i / particles.length) * Math.PI * 2 + Math.random()*0.6;
      const p = heartXY(t);
      particles[i].tx = center.x + p.x * scale + (Math.random()-0.5)*6;
      particles[i].ty = center.y - p.y * scale + (Math.random()-0.5)*6;
    }
    // slightly shift center over time for breathing
  }

  // emitTrail already defined above
  // start loop
  recomputeTargets();
  last = performance.now();
  requestAnimationFrame(tick);

  // periodic gentle recompute to avoid static layout
  setInterval(() => {
    recomputeTargets();
  }, 2800);

  // handle visibility
  document.addEventListener('visibilitychange', ()=> {
    if(document.hidden === false){
      last = performance.now();
    }
  });

  // expose simple controls for density (optional debugging)
  window.__heartParticles = {
    setCount(n){
      // not dynamic in this simple impl; recommend regenerate manually
      console.warn('要调整粒子数量，请在脚本中修改 PARTICLE_COUNT 并刷新页面。');
    }
  };

})();
  </script>
</body>
</html>