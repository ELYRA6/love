<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>给宝宝的小爱心</title>
<style>
  :root{
    --bg1:#fff0f6;
    --bg2:#ffeafa;
    --accent1:#ff6fa3;
    --accent2:#ff2e6d;
    --accent3:#ff9bb3;
    --glow: rgba(255,82,130,0.25);
  }

  html,body{
    height:100%;
    margin:0;
    font-family: -apple-system, "PingFang SC", "Microsoft YaHei", "Segoe UI", Roboto, sans-serif;
    -webkit-font-smoothing:antialiased;
  }

  /* 背景：动感渐变 + 轻微浮动 */
  .stage{
    min-height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    flex-direction:column;
    background: radial-gradient(circle at 20% 20%, rgba(255,230,240,0.6), transparent 15%),
                radial-gradient(circle at 80% 80%, rgba(255,245,220,0.6), transparent 12%),
                linear-gradient(135deg, var(--bg1), var(--bg2));
    overflow:hidden;
    position:relative;
    animation: bgShift 8s ease-in-out infinite;
  }
  @keyframes bgShift{
    0%{filter: hue-rotate(0deg) saturate(1);}
    50%{filter: hue-rotate(8deg) saturate(1.05);}
    100%{filter: hue-rotate(0deg) saturate(1);}
  }

  /* 主心形：使用伪元素构造，添加渐变、发光、投影和跳动 */
  .heart-wrap{
    position:relative;
    width:240px;
    height:220px;
    display:flex;
    align-items:center;
    justify-content:center;
    transform-origin:center;
  }

  .heart{
    width:140px;
    height:120px;
    position:relative;
    transform: rotate(45deg);
    border-radius:20px 20px 0 0;
    background: linear-gradient(180deg, #ff90b0 0%, #ff3a73 60%, #ff2e6d 100%);
    box-shadow: 0 12px 36px rgba(255,60,120,0.12), 0 0 80px rgba(255,82,130,0.14);
    animation: heartBeat 1.6s ease-in-out infinite, gentleSway 6s ease-in-out infinite;
    filter: drop-shadow(0 10px 30px rgba(255,100,140,0.12));
  }

  /* 保留两个圆瓣（lobe），做更柔和的过渡 */
  .heart::before,
  .heart::after{
    content:"";
    position:absolute;
    width:140px;
    height:120px;
    background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.00)),
                linear-gradient(180deg, #ff90b0 0%, #ff3a73 60%);
    border-radius:50%;
    left:0;
    top:-60px;
    transform-origin:center;
    opacity:0.98;
    filter: blur(0.6px);
  }
  .heart::after{
    left:-60px;
    top:0;
  }

  /* 缓慢放大的发光层（稍微放慢节奏）*/
  .heart-glow{
    position:absolute;
    width:240px;
    height:240px;
    border-radius:50%;
    background:
      radial-gradient(circle at 30% 30%, rgba(255,110,160,0.18), transparent 22%),
      radial-gradient(circle at 70% 70%, rgba(255,150,190,0.10), transparent 18%);
    filter: blur(18px);
    z-index:-2;
    animation: glowPulse 3.2s ease-in-out infinite;
  }

  /* 光泽移动更慢更悠扬 */
  .heart-sheen{
    position:absolute;
    width:96px;height:84px;
    left:50%;top:50%;
    transform:translate(-50%,-50%) rotate(45deg);
    background: linear-gradient(120deg, rgba(255,255,255,0.45), rgba(255,255,255,0.06));
    border-radius:14px 14px 0 0;
    filter: blur(6px);
    mix-blend-mode:screen;
    animation: sheenMove 4.2s infinite linear;
    pointer-events:none;
  }

  /* 新增：心形叠层，增加柔和光斑与微旋转，增加浪漫感 */
  .heart-overlay{
    position:absolute;
    width:260px;
    height:260px;
    left:50%; top:50%;
    transform:translate(-50%,-50%);
    border-radius:50%;
    background:
      radial-gradient(circle at 30% 30%, rgba(255,220,238,0.28), transparent 18%),
      radial-gradient(circle at 70% 70%, rgba(255,240,245,0.22), transparent 20%);
    mix-blend-mode: soft-light;
    pointer-events:none;
    z-index:-1;
    filter: blur(8px);
    animation: overlayPulse 5.6s ease-in-out infinite;
  }

  /* 动画 keyframes（替换/新增） */
  @keyframes heartBeat{
    0%,100%{ transform: rotate(45deg) scale(1) translateY(0); }
    50%{ transform: rotate(45deg) scale(1.12) translateY(-6px); }
  }
  @keyframes gentleSway{
    0%{ transform: rotate(44.6deg) translateY(0); }
    25%{ transform: rotate(45.4deg) translateY(-2px); }
    50%{ transform: rotate(45deg) translateY(0); }
    75%{ transform: rotate(45.6deg) translateY(-2px); }
    100%{ transform: rotate(44.6deg) translateY(0); }
  }
  @keyframes glowPulse{
    0%,100%{ transform: scale(1); opacity:0.9; }
    50%{ transform: scale(1.14); opacity:1; }
  }
  @keyframes sheenMove{
    0%{ transform:translate(-62%,-56%) rotate(45deg); opacity:0.78; }
    50%{ transform:translate(-38%,-44%) rotate(45deg); opacity:1; }
    100%{ transform:translate(-62%,-56%) rotate(45deg); opacity:0.78; }
  }
  @keyframes overlayPulse{
    0%{ transform: translate(-50%,-50%) scale(0.98) rotate(-2deg); opacity:0.9; }
    50%{ transform: translate(-50%,-52%) scale(1.03) rotate(2deg); opacity:1; }
    100%{ transform: translate(-50%,-50%) scale(0.98) rotate(-2deg); opacity:0.9; }
  }

  /* 中心小心形闪烁（填色渐变移动） */
  .heart-sheen{
    position:absolute;
    width:80px;height:70px;
    left:50%;top:50%;
    transform:translate(-50%,-50%) rotate(45deg);
    background: linear-gradient(120deg, rgba(255,255,255,0.4), rgba(255,255,255,0.06));
    border-radius:12px 12px 0 0;
    filter: blur(6px);
    mix-blend-mode:screen;
    animation: sheenMove 2.6s infinite linear;
    pointer-events:none;
  }
  @keyframes sheenMove{
    0%{ transform:translate(-62%,-56%) rotate(45deg); opacity:0.78; }
    50%{ transform:translate(-38%,-44%) rotate(45deg); opacity:1; }
    100%{ transform:translate(-62%,-56%) rotate(45deg); opacity:0.78; }
  }

  /* 漂浮小爱心：由 JS 生成并上升消失 */
  .float-heart{
    position:absolute;
    width:18px;height:18px;
    transform: rotate(45deg);
    background: linear-gradient(180deg, var(--accent3), var(--accent2));
    border-radius:4px 4px 0 0;
    opacity:0.95;
    pointer-events:none;
    box-shadow:0 6px 12px rgba(255,80,140,0.18);
  }
  .float-heart::before, .float-heart::after{
    content:"";
    position:absolute;
    width:18px;height:18px;
    background:inherit;
    border-radius:50%;
    top:-9px; left:0;
  }
  .float-heart::after{ left:-9px; top:0; }

/* 替换原来的 .text 规则为下面内容 */
.text{
    position:relative;             /* 便于放置伪元素作为底板 */
    margin-top:26px;
    font-size:20px;
    font-weight:700;
    white-space:nowrap;
    overflow:hidden;
    box-sizing:content-box;

    /* 文字渐变，保留原有样式 */
    background: linear-gradient(90deg, #fff7ff, #ffd6e6 40%, #fff 80%);
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;

    /* 保持打字效果（宽度按字符数调节）*/
    width:10.5ch;
    border-right: 2px solid rgba(255,255,255,0.7);
    animation: typing 2.4s steps(11,end) 1, blink 1s step-end infinite;

    z-index:1;                     /* 保证文字在伪元素上层 */
    padding:8px 18px;              /* 为底板留出空间 */
    border-radius:12px;
    text-shadow: 0 6px 18px rgba(0,0,0,0.22); /* 加强可读性 */
}

/* 底板：半透明 + 毛玻璃模糊，增强与背景的对比 */
.text::before{
    content:'';
    position:absolute;
    left:0;
    top:50%;
    transform:translateY(-50%);
    width:100%;
    height:100%;
    background: rgba(237, 46, 122, 0.18); /* 深色半透明，可调节透明度 */
    border-radius:12px;
    z-index:-1;
    backdrop-filter: blur(6px); /* 毛玻璃效果（移动端现代浏览器支持）*/
    -webkit-backdrop-filter: blur(6px);
    box-shadow: 0 8px 20px #f65a9814;
}s

/* 小屏适配（必要时减小内边距与宽度） */
@media (max-width:420px){
    .text{ font-size:18px; width:9ch; padding:6px 12px; border-radius:10px; }
    .text::before{ border-radius:10px; }
}
</style>
</head>
<body>
  <div class="stage">
    <!-- 替换原来 <div class="heart"> ... </div> 为 Canvas 实现 -->
    <div class="heart-wrap" aria-hidden="true">
      <canvas id="heartCanvas" width="720" height="620" style="width:100%;height:100%;display:block;"></canvas>
      <div class="heart-glow"></div>
      <div class="heart-sheen"></div>
      <div class="heart-overlay" aria-hidden="true"></div>
    </div>

    <div class="text">宝宝，我想你了 ❤</div>

    <div class="footer-note">我每时每刻都在想我的宝宝哦 ~</div>
  </div>

  <script>
(function(){
  const canvas = document.getElementById('heartCanvas');
  const ctx = canvas.getContext('2d', { alpha: true });
  const DPR = Math.max(1, window.devicePixelRatio || 1);

  // 屏幕相关变量（先声明）
  let center = { x: 0, y: 0 };
  let scale = 1;

  function resize() {
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.round(rect.width * DPR);
    canvas.height = Math.round(rect.height * DPR);
    // 使用像素比设置变换，这样后续绘制都以 CSS 像素为单位
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    center = { x: rect.width / 2, y: rect.height / 2 - 10 };
    scale = Math.min(rect.width, rect.height) / 38;
  }
  window.addEventListener('resize', resize);
  resize();

  function heartXY(t){
    const x = 16 * Math.pow(Math.sin(t),3);
    const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
    return { x, y };
  }

  // 粒子（在 resize 之后初始化）
  const PARTICLE_COUNT = 600; // 手机上建议 400-700 之间
  const particles = [];
  const trails = [];

  function initParticles(){
    particles.length = 0;
    for(let i=0;i<PARTICLE_COUNT;i++){
      const t = Math.random() * Math.PI * 2;
      const p = heartXY(t);
      const tx = center.x + p.x * scale + (Math.random()-0.5)*8;
      const ty = center.y - p.y * scale + (Math.random()-0.5)*8;
      particles.push({
        x: center.x + (Math.random()-0.5)*200,
        y: center.y + (Math.random()-0.5)*200,
        tx, ty, vx:0, vy:0,
        size: Math.random()*1.4 + 0.6,
        hue: 330 + Math.random()*20,
        flick: Math.random()*1200,
        phase: Math.random()*Math.PI*2
      });
    }
  }

  // 拖尾发射
  function emitTrail(){
    const baseX = center.x;
    const baseY = center.y + 36 * scale;
    const count = 4 + Math.floor(Math.random()*5);
    for(let i=0;i<count;i++){
      trails.push({
        x: baseX + (Math.random()-0.5)*18,
        y: baseY + (Math.random()*8),
        vx: (Math.random()-0.5)*0.5,
        vy: - (1.2 + Math.random()*1.8),
        life: 1000 + Math.random()*1200,
        size: 1.0 + Math.random()*2.2,
        hue: 320 + Math.random()*40,
        t0: performance.now()
      });
    }
    if(trails.length > 400) trails.splice(0, trails.length-400);
  }

  // 在 resize 后初始化并启动
  initParticles();

  // 渲染循环（改用清除整个像素画布）
  let last = performance.now();
  function tick(now){
    const dt = now - last;
    last = now;

    // 清除物理像素区（使用 canvas.width/height）
    ctx.clearRect(0,0, canvas.width / DPR, canvas.height / DPR);

    // 背景 glow
    const g = ctx.createRadialGradient(center.x, center.y, 10, center.x, center.y, Math.max(canvas.width, canvas.height));
    g.addColorStop(0, 'rgba(255,110,160,0.18)');
    g.addColorStop(0.4, 'rgba(255,140,180,0.06)');
    g.addColorStop(1, 'rgba(255,140,160,0)');
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(center.x, center.y, Math.max(canvas.width, canvas.height) * 0.18, 0, Math.PI*2);
    ctx.fill();

    // 粒子朝目标点弹簧运动
    for(let i=0;i<particles.length;i++){
      const p = particles[i];
      const wobble = Math.sin((now + p.phase*800)/ (1200 + p.flick)) * 5;
      const tx = p.tx + wobble * Math.cos(p.phase);
      const ty = p.ty + wobble * Math.sin(p.phase);

      const ax = (tx - p.x) * 0.002 * Math.min(3, dt/16);
      const ay = (ty - p.y) * 0.002 * Math.min(3, dt/16);
      p.vx += ax; p.vy += ay;
      p.vx *= 0.92; p.vy *= 0.92;
      p.x += p.vx * (dt/16);
      p.y += p.vy * (dt/16);

      const alpha = 0.5 + 0.45 * Math.abs(Math.sin((now + i*11) / (700 + (i%6)*25)));
      const rad = p.size * (1 + 0.4*Math.sin(now/900 + i));
      ctx.globalCompositeOperation = 'lighter';
      ctx.fillStyle = `hsla(${p.hue},90%,65%,${alpha})`;
      ctx.fillRect(p.x - rad*1.4, p.y - rad*1.4, rad*2.8, rad*2.8);
      ctx.beginPath();
      ctx.fillStyle = `hsla(${p.hue},95%,72%,${Math.min(1,alpha+0.12)})`;
      ctx.arc(p.x, p.y, Math.max(0.4, rad*0.5), 0, Math.PI*2);
      ctx.fill();
      ctx.globalCompositeOperation = 'source-over';
    }

    // trails
    for(let i=trails.length-1;i>=0;i--){
      const tr = trails[i];
      const age = now - tr.t0;
      if(age > tr.life){ trails.splice(i,1); continue; }
      tr.vx += (Math.sin((now + i*29)/2000))*0.0008;
      tr.vy += 0.003;
      tr.x += tr.vx * (dt/16);
      tr.y += tr.vy * (dt/16);
      const tnorm = age / tr.life;
      const a = 1 - tnorm;
      ctx.globalCompositeOperation = 'lighter';
      const gradient = ctx.createRadialGradient(tr.x, tr.y, 0, tr.x, tr.y, tr.size*7);
      gradient.addColorStop(0, `hsla(${tr.hue},92%,68%,${0.9*a})`);
      gradient.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(tr.x - tr.size*3.5, tr.y - tr.size*3.5, tr.size*7, tr.size*7);
      ctx.beginPath();
      ctx.fillStyle = `hsla(${tr.hue},88%,70%,${0.95*a})`;
      ctx.arc(tr.x, tr.y, tr.size*0.8, 0, Math.PI*2);
      ctx.fill();
      ctx.globalCompositeOperation = 'source-over';
    }

    if(Math.random() < 0.06) emitTrail();
    requestAnimationFrame(tick);
  }

  // 重新计算目标点（在 resize 或周期性调用）
  function recomputeTargets(){
    for(let i=0;i<particles.length;i++){
      const t = (i / particles.length) * Math.PI * 2 + Math.random()*0.6;
      const p = heartXY(t);
      particles[i].tx = center.x + p.x * scale + (Math.random()-0.5)*6;
      particles[i].ty = center.y - p.y * scale + (Math.random()-0.5)*6;
    }
  }

  // 在 window resize 时重建目标（保证形状）
  window.addEventListener('resize', () => {
    resize();
    recomputeTargets();
  });

  recomputeTargets();
  last = performance.now();
  requestAnimationFrame(tick);

  // 可调：降低数量或缩短频率进一步优化性能
  window.__heartParticles = { setCount(n){ console.warn('请在脚本中修改 PARTICLE_COUNT 并刷新页面。'); } };

})();
  </script>
</body>
</html>